/*
 * generated by Xtext 2.35.0
 */
package es.unican.istr.xtext.validation;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Objects;
import java.util.Properties;
import java.util.Set;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;

import es.unican.istr.pasys.pasys.*;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MyPasysValidator extends AbstractMyPasysValidator {

	// Every EInt and ELong attribute must be greater than 0
	public static final int MINIMUM_NUMERICAL_VALUE = 0;
	// Minimum and maximum port values
	public static final int MINIMUM_PORT = 1024;
	public static final int MAXIMUM_PORT = 65535;
	
	// Empty string field
	public static final String EMPTY_FIELD = "emptyField";
	
	// Negative numeric value
	public static final String NEGATIVE_NUMERIC_VALUE= "negativeNumericValue";
	
    // Expresión regular que representa una dirección IPv4 (Cadena de texto formada por cuatro octetos expresados en formato decimal y separados por puntos)
	public static final String IP_PATTERN = 
		    "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}" +
		    "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
	public static final String INVALID_IP = "invalidIp";
	
	// key-value pattern string
	public static final String KEY_VALUE_EQUALS_PATTERN = "^(\\s*[^=\\s]+\\s*=\\s*[^=\\s]+\\s*)(,\\s*[^=\\s]+\\s*=\\s*[^=\\s]+\\s*)*$";
	public static final String KEY_VALUE_COLON_PATTERN = "^\\{\\s*[^:\\s]+\\s*:\\s*[^,}\\s]+\\s*(,\\s*[^:\\s]+\\s*:\\s*[^,}\\s]+\\s*)*}$";
	public static final String INVALID_KEY_VALUE_FORMAT = "invalidKeyValue";

    // Ports
    public static final String INVALID_PORT_FORMAT = "invalidPortFormat";
    public static final String INVALID_PORT_VALUE = "invalidPortValue";
    public static final String SAME_PORTS = "samePort";
    
    // Properties
    public static final String PROPERTIES_PATTERN = "^([a-zA-Z0-9]+=[^,]+)(,\\s*[a-zA-Z0-9]+=[^,]+)*$";
    public static final String INVALID_PROPERTIES_PATTERN = "invalidPropertiesPattern";

    // Speed value
    public static final String INVALID_SPEED_FACTOR = "invalidSpeedFactor";
    
    // Expresión regular para validar paths de archivo (Linux/Windows)
    public static final String PATH_PATTERN = "^/?(?:[a-zA-Z0-9._-]+(/[a-zA-Z0-9._-]+)*)?$";

    public static final String INVALID_PATH = "invalidPath";
    public static final String DUPLICATE_PATHS = "duplicatePaths";

    // ConfigureDeploymentConf inválido
    public static final String INVALID_DEPLOYMENT_CONF = "invalidDeploymentConf";
    
    /**
     * Valida que todos los atributos de tipo EInt y ELong sean mayores o iguales que 0 en todos los elementos
     * @param object
     */
    @Check
    public void checkPositiveValues(Object object) {
        for (EStructuralFeature feature : ((EObject) object).eClass().getEAllStructuralFeatures()) {
            if (feature.getEType().getInstanceClass() == int.class 
            		|| feature.getEType().getInstanceClass() == long.class
            		|| feature.getEType().getInstanceClass() == double.class) {
                Object value = ((EObject) object).eGet(feature);
                
                if (value instanceof Integer) {
                    int intValue = (Integer) value;
                    if (intValue < 0) {
                        error("The value of " + feature.getName() + " must be greater or equals than 0", feature, NEGATIVE_NUMERIC_VALUE);
                    }
                } else if (value instanceof Long) {
                    long longValue = (Long) value;
                    if (longValue < 0) {
                        error("The value of " + feature.getName() + " must be greater or equal than 0", feature, NEGATIVE_NUMERIC_VALUE);
                    }
                } else if (value instanceof Double) {
                    double doubleValue = (Double) value;
                    if (doubleValue < 0) {
                        error("The value of " + feature.getName() + " must be greater or equal than 0", feature, NEGATIVE_NUMERIC_VALUE);
                    }
                }
            }
        }
    }
    
    /**
     * Valida que todos los atributos de tipo EString definidos sean distintos de cadena vacía
     * @param object
     */
    @Check
    public void checkNonEmptyEStringValues(Object object) {
        for (EStructuralFeature feature : ((EObject) object).eClass().getEAllStructuralFeatures()) {
            if (feature.getEType().getInstanceClass() == String.class && feature.isMany() == false) {
                Object value = ((EObject) object).eGet(feature);

                if (value instanceof String) {
                    String stringValue = (String) value;
                    if (stringValue.trim().isEmpty()) {
                        error("The value of '" + feature.getName() + "' must not be empty",
                              feature, EMPTY_FIELD);
                    }
                }
            }
        }
    }
    
    // Artifact Descriptor
    
    /** 
     * Valida que el campo "localPath" de ArtifactDescriptor sea correcto
     * @param artifactDescriptor
     */
    @Check
    public void checkValidArtifactDescriptorLocalPath(ArtifactDescriptor artifactDescriptor) {
        String path = artifactDescriptor.getLocalPath();
        
        if (!path.matches(PATH_PATTERN)) {
            error("Invalid file path. Please provide a valid file path (e.g., /usr/local/bin/file or C:\\Program Files\\file.txt).",
                    PasysPackage.Literals.ARTIFACT_DESCRIPTOR__LOCAL_PATH, INVALID_PATH);
        }
    }
    
    // AWS Virtual Processing Node
    
    /**
     * Valida que el campo "keyPair" de AWSVirtualProcessingNode cumpla con algún formato de clave-valor correcto
     * @param node
     */
    @Check
    public void checkAWSVirtualProcessingNodeKeyPair(AWSVirtualProcessingNode node) {
        String keyPair = node.getKeyPair();
        
        if (!keyPair.matches(KEY_VALUE_EQUALS_PATTERN) && !keyPair.matches(KEY_VALUE_COLON_PATTERN)) {
            error("Invalid keyPair format. The expected format is 'key=value' or '{key: value}' separated by commas.",
            		PasysPackage.Literals.AWS_VIRTUAL_PROCESSING_NODE__KEY_PAIR, INVALID_KEY_VALUE_FORMAT);
        }
    }
    
    // Cassandra Service
        
    /**
     * Valida que los campos "storagePort" "sslStoragePort" y "rcpPort" de CassandraService sean un número entero comprendido entre 1024 y 65535 (ambos incluidos)
     * @param cassandra
     */
    
    @Check
    public void checkCassandraServicePorts(CassandraService cassandraService) {
    	int storagePort = 0, sslStoragePort = 0, rcpPort = 0;
    	
        try {
        	storagePort = Integer.parseInt(cassandraService.getStoragePort());
        } catch (NumberFormatException e) {
            error("Storage port must be a valid integer.",
                    PasysPackage.Literals.CASSANDRA_SERVICE__STORAGE_PORT, INVALID_PORT_FORMAT);
        }

        try {
        	sslStoragePort = Integer.parseInt(cassandraService.getSslStoragePort());
        } catch (NumberFormatException e) {
            error("SslStorage port must be a valid integer.",
                    PasysPackage.Literals.CASSANDRA_SERVICE__SSL_STORAGE_PORT, INVALID_PORT_FORMAT);
        }

        try {
        	rcpPort = Integer.parseInt(cassandraService.getRpcPort());
        } catch (NumberFormatException e) {
            error("Rcp port must be a valid integer.",
                    PasysPackage.Literals.CASSANDRA_SERVICE__RPC_PORT, INVALID_PORT_FORMAT);
        }
        
        if (storagePort < MINIMUM_PORT || storagePort > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.CASSANDRA_SERVICE__STORAGE_PORT, INVALID_PORT_VALUE);
        }
        if (sslStoragePort < MINIMUM_PORT || sslStoragePort > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.CASSANDRA_SERVICE__SSL_STORAGE_PORT, INVALID_PORT_VALUE);
        }
        if (rcpPort < MINIMUM_PORT || rcpPort > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.CASSANDRA_SERVICE__RPC_PORT, INVALID_PORT_VALUE);
        }
        if (storagePort == sslStoragePort) {
        	error("storagePort and sslStoragePort should not be the same.",
        			PasysPackage.Literals.CASSANDRA_SERVICE__STORAGE_PORT, SAME_PORTS);
        }
        if (sslStoragePort == rcpPort) {
        	error("storagePort and sslStoragePort should not be the same.",
        			PasysPackage.Literals.CASSANDRA_SERVICE__SSL_STORAGE_PORT, SAME_PORTS);
        }
        if (storagePort == rcpPort) {
        	error("storagePort and sslStoragePort should not be the same.",
        			PasysPackage.Literals.CASSANDRA_SERVICE__STORAGE_PORT, SAME_PORTS);
        }
    }
        
    /**
     * Valida que los campos "dataFileDir" no esté vacío y cumpla con el formato de path correcto
     * @param cassandraService
     */
    @Check
    public void checkDataFileDir(CassandraService cassandraService) {
        String dataFileDir = cassandraService.getDataFileDir();

        if (!dataFileDir.matches(PATH_PATTERN)) {
            error("Invalid dataFileDir path. Please provide a valid dataFileDir path (e.g., /usr/local/bin/file or C:\\Program Files\\file.txt).",
                  PasysPackage.Literals.CASSANDRA_SERVICE__DATA_FILE_DIR, 
                  INVALID_PATH);
        }
    }

    /**
     * Valida que los campos "endPointSnitch" no esté vacío y cumpla con el formato de path correcto
     * @param cassandraService
     */
    @Check
    public void checkEndPointSnitch(CassandraService cassandraService) {
        String endPointSnitch = cassandraService.getEndpointSnitch();
        
        if (!endPointSnitch.matches(PATH_PATTERN)) {
            error("Invalid endPointSnitch path. Please provide a valid endPointSnitch path (e.g., /usr/local/bin/file or C:\\Program Files\\file.txt).",
                  PasysPackage.Literals.CASSANDRA_SERVICE__ENDPOINT_SNITCH, 
                  EMPTY_FIELD);
        }
    }

    /**
     * Valida que los campos "seedProviderClass" no esté vacío y cumpla con el formato de path correcto
     * @param cassandraService
     */
    @Check
    public void checkSeedProviderClass(CassandraService cassandraService) {
        String seedProviderClass = cassandraService.getSeedProviderClass();
        
        if (!seedProviderClass.matches(PATH_PATTERN)) {
            error("Invalid seedProviderClass path. Please provide a valid seedProviderClass path (e.g., /usr/local/bin/file or C:\\Program Files\\file.txt).",
                  PasysPackage.Literals.CASSANDRA_SERVICE__SEED_PROVIDER_CLASS, 
                  EMPTY_FIELD);
        }
    }
    
    // Deployment Constraints
    
    @Check
    public void checkDeploymentConstraints(DeploymentConstraints deploymentConstraints) {
    	
    	Properties labels = deploymentConstraints.getLabels();
    	Properties resources = deploymentConstraints.getResources();

        if (labels != null)
        {
        	validateProperties(labels, PasysPackage.Literals.DEPLOYMENT_CONSTRAINTS__LABELS, "labels");

        }
    	if (resources != null) {
    		validateProperties(resources, PasysPackage.Literals.DEPLOYMENT_CONSTRAINTS__LABELS, "resources");

    	}

    }
    
    // FileDescriptor
    
    /** 
     * Valida el campo "filePath" de FileDescriptor sea correcto
     * @param fileDescriptor
     */
    @Check
    public void checkValidFileDescriptorPath(FileDescriptor fileDescriptor) {
        String path = fileDescriptor.getFilePath();
        
        if (!path.matches(PATH_PATTERN)) {
            error("Invalid file path. Please provide a valid file path "
            		+ "(e.g., /usr/local/bin/file or C:\\Program Files\\file.txt).",
                    PasysPackage.Literals.FILE_DESCRIPTOR__FILE_PATH, INVALID_PATH);
        }
    }

    // Kafka Flow Stream Data
    
    /**
     * Valida que el campo "holder" de un KafkaFlowStreamData sea de tipo KafkaService
     * @param kafkaFlowStreamData
     */
    @Check
    public void checkKafkaFlowStreamDataHolder(KafkaFlowStreamData kafkaFlowStreamData) {
    	CommunicationService kafkaService = kafkaFlowStreamData.getHolder();
    	
    	if(!(kafkaService instanceof KafkaService)) {
    		error("KafkaFlowStreamData's holder must be of type KafkaService",
    				PasysPackage.Literals.FLOW_STREAM_DATA__HOLDER);
    	}
    }
    
    // Kafka Service
    
    /**
     * Valida que el campo "clientPort" de KafkaService sea un número entero comprendido entre 1024 y 65535 (ambos incluidos)
     * @param kafka
     */
    @Check
    public void checkKafkaServiceClientPort(KafkaService kafka) {
        int clientPort = Integer.MIN_VALUE;
        
        try {
        	clientPort = Integer.parseInt(kafka.getClientPort());
        } catch (NumberFormatException e) {
            error("Client port must be a valid integer.",
                    PasysPackage.Literals.KAFKA_SERVICE__CLIENT_PORT, INVALID_PORT_FORMAT);
        }
        if (clientPort < MINIMUM_PORT || clientPort > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.KAFKA_SERVICE__CLIENT_PORT, INVALID_PORT_VALUE);
        }
    }
    
    // Kafka Workload Stream Data
    
    /**
     * Valida que el campo "holder" de un KafkaWorkloadStreamData sea de tipo KafkaService
     * @param kafkaWorkloadStreamData
     */
    @Check
    public void checkKafkaWorkloadStreamDataHolder(KafkaWorkloadStreamData kafkaWorkloadStreamData) {
    	CommunicationService kafkaService = kafkaWorkloadStreamData.getHolder();
    	
    	if(!(kafkaService instanceof KafkaService)) {
    		error("KafkaFlowStreamData's holder must be of type KafkaService",
    				PasysPackage.Literals.WORKLOAD_STREAM_DATA__HOLDER);
    	}
    }
    
    
    // Kubernetes Cluster
    
    /** 
     * Valida que el campo "kubeConfigPath" de KubernetesCluster sea correcto
     * @param kubernetesCluster
     */
    @Check
    public void checkKubernetesClusterKubeConfigPath(KubernetesCluster kubernetesCluster) {
        String kubeConfigPath = kubernetesCluster.getKubeConfigPath();
        
        if (!kubeConfigPath.matches(PATH_PATTERN)) {
            error("Invalid KubeConfigPath. Please provide a valid KubeConfigPath (e.g., /usr/local/bin/file or C:\\Program Files\\file.txt).",
                    PasysPackage.Literals.KUBERNETES_CLUSTER__KUBE_CONFIG_PATH, INVALID_PATH);
        }
    }
    
    
    // Kubernetes Deployment Conf
    
    /**
     * Valida que el campo "externalIp" de KubernetesDeploymentConf cumpla con el formato de IP correcto
     * @param kubernetesDeploymentConf
     */
    @Check
    public void checkValidExternalIp(KubernetesDeploymentConf kubernetesDeploymentConf) {
        String externalIP = kubernetesDeploymentConf.getExternalIP();
        
        if(externalIP == null)
        	return;
        
        if (!externalIP.matches(IP_PATTERN)) {
            error("Invalid external IP address format. "
            		+ "Expected format: xxx.xxx.xxx.xxx where each block is between 0-255",
                    PasysPackage.Literals.KUBERNETES_DEPLOYMENT_CONF__EXTERNAL_IP, INVALID_IP);
        }
    }
    
    
    // Node Deployment Conf
    
    /** 
     * Valida que el campo "artifactLocaltor" de NodeDeploymentConf no esté vacío y sea correcto
     * @param nodeDeploymentConf
     */
    @Check
    public void checkNodeDeploymentConfArtifactLocatorPath(NodeDeploymentConf nodeDeploymentConf) {
        String artifactLocator = nodeDeploymentConf.getArtifactLocator();
        
        if (!artifactLocator.matches(PATH_PATTERN)) {
            error("Invalid artifactLocator path. Please provide a valid file path.",
                  PasysPackage.Literals.NODE_DEPLOYMENT_CONF__ARTIFACT_LOCATOR, 
                  INVALID_PATH);
        }
    }
    
    /** 
     * Valida que el campo "codeFolderPath" de NodeDeploymentConf no esté vacío y sea correcto
     * @param nodeDeploymentConf
     */
    @Check
    public void checkNodeDeploymentConfCodeFolderPath(NodeDeploymentConf nodeDeploymentConf) {
        String codeConfigPath = nodeDeploymentConf.getCodeFolderPath();
        
        if (!codeConfigPath.matches(PATH_PATTERN)) {
            error("Invalid codeFolder path. Please provide a valid file path.",
                  PasysPackage.Literals.NODE_DEPLOYMENT_CONF__CODE_FOLDER_PATH, 
                  INVALID_PATH);
        }
    }

    /** 
     * Valida que el campo "configFolderPath" de NodeDeploymentConf no esté vacío y sea correcto
     * @param nodeDeploymentConf
     */
    @Check
    public void checkNodeDeploymentConfConfigFolderPath(NodeDeploymentConf nodeDeploymentConf) {
        String configFolderPath = nodeDeploymentConf.getConfigFolderPath();
        
        if (!configFolderPath.matches(PATH_PATTERN)) {
            error("Invalid configFolder path. Please provide a valid file path.",
                  PasysPackage.Literals.NODE_DEPLOYMENT_CONF__CONFIG_FOLDER_PATH, 
                  INVALID_PATH);
        }
    }

    /** 
     * Valida que el campo "dataFolderPath" de NodeDeploymentConf no esté vacío y sea correcto
     * @param nodeDeploymentConf
     */
    @Check
    public void checkNodeDeploymentConfDataFolderPath(NodeDeploymentConf nodeDeploymentConf) {
        String dataFolderPath = nodeDeploymentConf.getDataFolderPath();
        
        if (!dataFolderPath.matches(PATH_PATTERN)) {
            error("Invalid dataFolder path. Please provide a valid file path.",
                  PasysPackage.Literals.NODE_DEPLOYMENT_CONF__DATA_FOLDER_PATH, 
                  INVALID_PATH);
        }
    }

    /** 
     * Valida que el campo "logFolderPath" de NodeDeploymentConf no esté vacío y sea correcto
     * @param nodeDeploymentConf
     */
    @Check
    public void checkNodeDeploymentConfLogFolderPath(NodeDeploymentConf nodeDeploymentConf) {
        String logFolderPath = nodeDeploymentConf.getLogFolderPath();
        
        if (!logFolderPath.matches(PATH_PATTERN)) {
            error("Invalid logFolder path. Please provide a valid file path.",
                  PasysPackage.Literals.NODE_DEPLOYMENT_CONF__LOG_FOLDER_PATH, 
                  INVALID_PATH);
        }
    }

    /** 
     * Valida que el campo "scriptFolderPath" de NodeDeploymentConf no esté vacío y sea correcto
     * @param nodeDeploymentConf
     */
    @Check
    public void checkNodeDeploymentConfScriptFolderPath(NodeDeploymentConf nodeDeploymentConf) {
        String scriptFolderPath = nodeDeploymentConf.getScriptFolderPath();
        
        if (!scriptFolderPath.matches(PATH_PATTERN)) {
            error("Invalid scriptFolder path. Please provide a valid file path.",
                  PasysPackage.Literals.NODE_DEPLOYMENT_CONF__SCRIPT_FOLDER_PATH, 
                  INVALID_PATH);
        }
    }

    /**
     * Valida que el campo "arguments" de NodeDeploymentConf no contiene ningún argumento vacío
     * @param nodeDeploymentConf
     */
    @Check
    public void checkNodeDeploymentConfArguments(NodeDeploymentConf nodeDeploymentConf) {
    	EList<String> arguments = nodeDeploymentConf.getArguments();
    	
    	if(arguments == null)
    		return;
    	
        for (String argument : arguments) {
            if (argument.trim().isEmpty()) {
                error("Arguments cannot contain empty values. Please remove or replace empty arguments.",
                      PasysPackage.Literals.NODE_DEPLOYMENT_CONF__ARGUMENTS, EMPTY_FIELD);
            }
        }
    }
    
    /**
     * Valida que los diferentes paths de NodeDeploymentConf no sean iguales
     * @param nodeDeploymentConf
     */
    @Check
    public void checkNodeDeploymentConfDuplicatePaths(NodeDeploymentConf nodeDeploymentConf) {
        // Obtén todos los valores opcionales
        String artifactLocator = nodeDeploymentConf.getArtifactLocator();
        String codeFolderPath = nodeDeploymentConf.getCodeFolderPath();
        String configFolderPath = nodeDeploymentConf.getConfigFolderPath();
        String dataFolderPath = nodeDeploymentConf.getDataFolderPath();
        String logFolderPath = nodeDeploymentConf.getLogFolderPath();
        String scriptFolderPath = nodeDeploymentConf.getScriptFolderPath();

        Set<String> paths = new HashSet<>(
            Arrays.asList(artifactLocator, codeFolderPath, configFolderPath, dataFolderPath, logFolderPath, scriptFolderPath)
            .stream()
            .filter(Objects::nonNull)
            .toList()
        );

        long nonNullPathsCount = Arrays.asList(artifactLocator, codeFolderPath, configFolderPath, dataFolderPath, logFolderPath, scriptFolderPath)
            .stream()
            .filter(Objects::nonNull)
            .count();

        if (paths.size() < nonNullPathsCount) {
            error("Paths must be unique. Found duplicate paths.",
                  PasysPackage.Literals.NODE_DEPLOYMENT_CONF__ARTIFACT_LOCATOR, 
                  DUPLICATE_PATHS);
        }
    }
    
    // Nomad Cluster
    
    /**
     * Valida que el campo "ip" de NomadCluster cumpla con el formato de IP correcto
     * @param kubernetesDeploymentConf
     */
    @Check
    public void checkNomadClusterIp(NomadCluster nomadCluster) {
        String ip = nomadCluster.getIp();
        
        if (!ip.matches(IP_PATTERN)) {
            error("Invalid external IP address format. Expected format: xxx.xxx.xxx.xxx where each block is between 0-255",
                    PasysPackage.Literals.NOMAD_CLUSTER__IP, INVALID_IP);
        }
        
    }
    
    /**
     * Valida que el campo "port" de NomadCluster sea un número entero comprendido entre 1024 y 65535 (ambos incluidos)
     * @param cluster
     */
    @Check
    public void checkNomadClusterPort(NomadCluster nomadCluster) {
    	int port = Integer.MIN_VALUE;
    	
        try {
            port = Integer.parseInt(nomadCluster.getPort());
        } catch (NumberFormatException e) {
            error("Port must be a valid number.", 
                    PasysPackage.Literals.NOMAD_CLUSTER__PORT, INVALID_PORT_FORMAT);
        }
        if (port < MINIMUM_PORT || port > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.NOMAD_CLUSTER__PORT, INVALID_PORT_VALUE);
        }
        
    }
    
    
    // Orchestrator Deployment Conf
    
    /**
     * Valida que el atributo "ENV" de un OrchestratorDeploymentConf cumpla con el formato de un objeto Properties.
     * @param orchestratorDeploymentConf
     */
    @Check
    public void checkOrchestratorDeploymentConfEnv(OrchestratorDeploymentConf orchestratorDeploymentConf) {
        Properties env = orchestratorDeploymentConf.getEnv();
        
        if (env == null)
        	return;
        
        validateProperties(env, PasysPackage.Literals.ORCHESTRATOR_DEPLOYMENT_CONF__ENV, "env");
    }
    
    
    
    // Persistence Service
    
    /**
     * Valida que el campo "port" de PersistenceService (CassandraService, Neo4JService y MemSQLService) sea un número entero comprendido entre 1024 y 65535 (ambos incluidos)
     * @param persistenceService
     */
    @Check
    public void checkValidPort(PersistenceService persistenceService) {
        int port = persistenceService.getPort();
        
        if (port < MINIMUM_PORT || port > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.PERSISTENCE_SERVICE__PORT, INVALID_PORT_VALUE);
        }
    }
    
    // Platform Service
    
    /**
     * Valida que los campos "host" y "deploymentConfiguration" sean compatibles para un PlatformService (Cassandra, Zookeeper...) de modo que:
     * - Si host: ProcessingNodeCluster => deploymentConfig: NodeDeploymentConfig
	 * - Si host: OrchestrationCluster => deploymentConfig:OrchestratorDeploymentConfig
     * @param platformService
     */
    @Check
    public void checkValidHostAndDeploymentConfig(PlatformService platformService) {
    	ProcessingResourceCluster host = platformService.getHost();
        DeploymentConfiguration deploymentConfig = platformService.getDeploymentConfig();
        
        if (host instanceof ProcessingNodeCluster) {
            if (!(deploymentConfig instanceof NodeDeploymentConf)) {
                error("If host is of type ProcessingNodeCluster, deployment configuration must be of type NodeDeploymentConf.",
                      PasysPackage.Literals.PLATFORM_SERVICE__HOST, INVALID_DEPLOYMENT_CONF);
            }
        }
        else if (host instanceof KubernetesCluster) {
            if (!(deploymentConfig instanceof KubernetesDeploymentConf)) {
                error("If host is of type KubernetesCluster, deployment configuration must be of type KubernetesDeploymentConf.",
                      PasysPackage.Literals.PLATFORM_SERVICE__HOST, INVALID_DEPLOYMENT_CONF);
            }
        }
        else if (host instanceof SwarmCluster) {
            if (!(deploymentConfig instanceof SwarmDeploymentConf)) {
                error("If host is of type SwarmCluster, deployment configuration must be of type SwarmDeploymentConf.",
                      PasysPackage.Literals.PLATFORM_SERVICE__HOST, INVALID_DEPLOYMENT_CONF);
            }
        }
        else if (host instanceof NomadCluster) {
            if (!(deploymentConfig instanceof NomadDeploymentConf)) {
                error("If host is of type NomadCluster, deployment configuration must be of type NomadDeploymentConf.",
                      PasysPackage.Literals.PLATFORM_SERVICE__HOST, INVALID_DEPLOYMENT_CONF);
            }
        }
    }
    
    // Processing Node
    
    /**
     * Valida que el atributo "configData" de ProcessingNode cumpla con el formato de un objeto Properties.
     * @param node
     */
    @Check
    public void checkConfigDataFormat(ProcessingNode node) {
        Properties configData = node.getConfigData();
        
        if (configData == null)
        	return;
        
        validateProperties(configData, PasysPackage.Literals.PROCESSING_NODE__CONFIG_DATA, "configData");
    }
    
    /**
     * Valida que el campo "ip" de ProcessingNode cumpla con un patrón de IP correto
     * @param node
     */
    @Check
    public void checkProcessingNodeIp(ProcessingNode node) {
    	String nodeIP = node.getIp();
    	
        if (!nodeIP.matches(IP_PATTERN)) {
        	error("Invalid IP address format. Expected format: xxx.xxx.xxx.xxx where each block is between 0-255",
					PasysPackage.Literals.PROCESSING_NODE__IP, INVALID_IP);
        }
    }

    /**
     * Valida que el campo "speedFactor" de ProcessingNode se encuentre entre 0 y 1 (ambos incluidos)
     * @param node
     */
    @Check
    public void checkSpeedFactor(ProcessingNode node) {
    	double speedFactor = node.getSpeedFactor();
    	
    	if(speedFactor > 1) {
    		error("Invalid speedFactor. Value must be between 0 and 1",
    				PasysPackage.Literals.PROCESSING_NODE__SPEED_FACTOR, INVALID_SPEED_FACTOR);
    	}
    }
    
    // Prometheus Meter
    
    /**
     * Valida que el campo "monitoringPort" de PrometheusMeter sea un número entero comprendido entre 1024 y 65535 (ambos incluidos)
     * @param meter
     */
    @Check
    public void checkValidMonitoringPort(PrometheusMeter meter) {
    	int monitoringPort = Integer.MIN_VALUE;
        
        try {
        	monitoringPort = Integer.parseInt(meter.getMonitoringPort());
        } catch (NumberFormatException e) {
            error("Monitoring port must be a valid integer.",
                    PasysPackage.Literals.PROMETHEUS_METER__MONITORING_PORT, INVALID_PORT_FORMAT);
        }
        
        if (monitoringPort < MINIMUM_PORT || monitoringPort > MAXIMUM_PORT) {
            error("Monitoring port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.PROMETHEUS_METER__MONITORING_PORT, INVALID_PORT_VALUE);
        }
    }

    // Spark Service
    
    /**
     * Valida que el campo "localDir" de SparkService corresponda a un path correcto y
     * que el campo "driverMaxResultSize" de SparkService represente un número entero
     * @param sparkService
     */
    @Check
    public void checkSparkService(SparkService sparkService) {
    	String localDir = sparkService.getLocalDir();    
    	    
        if (!localDir.matches(PATH_PATTERN)) {
            error("Invalid localDir path. Please provide a valid file path (e.g., /usr/local/bin/file or C:\\Program Files\\file.txt).",
                    PasysPackage.Literals.SPARK_SERVICE__LOCAL_DIR, INVALID_PATH);
        }
        
    	String driverMaxResultSize = sparkService.getDriverMaxResultSize();
    	
    	if(driverMaxResultSize == null)
    		return;
    	
    	int driverMaxResultSizeInt = Integer.MIN_VALUE;

        try {
        	driverMaxResultSizeInt = Integer.parseInt(driverMaxResultSize);
        } catch (NumberFormatException e) {
            error("DriverMaxResultSize must be a valid integer.",
                    PasysPackage.Literals.SPARK_SERVICE__DRIVER_MAX_RESULT_SIZE, INVALID_PORT_FORMAT);
        }
        
        if (driverMaxResultSizeInt < 0)
        	error("DriverMaxResultSize must be greater than 0",
        			PasysPackage.Literals.SPARK_SERVICE__DRIVER_MAX_RESULT_SIZE, NEGATIVE_NUMERIC_VALUE);

        
    }
    
    // Storm Service
    
    /**
     * Valida que el campo "localDir" de Storm Service sea correcto
     * @param stormService
     */
    @Check
    public void checkStormService(StormService stormService) {
    	String localDir = stormService.getLocalDir();  
    	
    	if (!localDir.matches(PATH_PATTERN)) {
            error("Invalid localDir path. Please provide a valid file path (e.g., /usr/local/bin/file or C:\\Program Files\\file.txt).",
                    PasysPackage.Literals.STORM_SERVICE__LOCAL_DIR, INVALID_PATH);
        }
        
    }
    
    // Storm Supervisor
    
    /**
     * Valida que el campo "supervisorSlotsPorts" tenga los puertos en un formato correcto y estén comprendidos entre los 
     * valores 1024 y 65534 (ambos incluidos)
     * @param stormSupervisor
     */
    @Check
    public void checkStormSupervisor(StormSupervisor stormSupervisor) {
    	EList<String> supervisorSlotsPorts = stormSupervisor.getSupervisorSlotPorts();
    	
        for (String portStr : supervisorSlotsPorts) {
            int port = Integer.MIN_VALUE;
            
            try {
                port = Integer.parseInt(portStr);
            } catch (NumberFormatException e) {
                error("Supervisor slot port '" + portStr + "' is not a valid number.",
                        PasysPackage.Literals.STORM_SUPERVISOR__SUPERVISOR_SLOT_PORTS,
                        stormSupervisor.getSupervisorSlotPorts().indexOf(portStr),
                        INVALID_PORT_FORMAT);
                continue;
            }
            
            if (port < 1024 || port > 65535) {
                error("Supervisor slot port " + port + " must be between 1024 and 65535.",
                        PasysPackage.Literals.STORM_SUPERVISOR__SUPERVISOR_SLOT_PORTS,
                        stormSupervisor.getSupervisorSlotPorts().indexOf(portStr),
                        INVALID_PORT_VALUE);
            }
        }
    }
    
    // Storm UI

    /**
     * Valida que el campo "uiPort" de StormUI sea un número entero 
     * comprendido entre 1024 y 65535 (ambos incluidos)
     * @param stormUI
     */
    @Check
    public void checkStormUI(StormUI stormUI) {
    	int uiPort = Integer.MIN_VALUE;
       
        try {
        	uiPort = Integer.parseInt(stormUI.getUiPort());
        } catch (NumberFormatException e) {
            error("UI port must be a valid integer.",
                    PasysPackage.Literals.STORM_UI__UI_PORT, INVALID_PORT_FORMAT);
        }
        
        if (uiPort < MINIMUM_PORT || uiPort > MAXIMUM_PORT) {
            error("UI number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.STORM_UI__UI_PORT, INVALID_PORT_VALUE);
        }
    }
    
    // Swarm Cluster

    /**
     * Valida que el campo "ip" de SwarmCluster cumpla con un patrón de IP correto
     * @param swarmCluster
     */
    @Check
    public void checkSwarmClusterlIp(SwarmCluster swarmCluster) {
        String ip = swarmCluster.getIp();
        
        if (!ip.matches(IP_PATTERN)) {
        	error("Invalid IP address format. Expected format: xxx.xxx.xxx.xxx where each block is between 0-255",
					PasysPackage.Literals.SWARM_CLUSTER__IP, INVALID_IP);
        }
    }
    
    /**
     * Valida que el campo "port" de SwarmCluster sea un número entero comprendido entre 1024 y 65535 (ambos incluidos)
     * @param swarmCluster
     */
    @Check
    public void checkSwarmClusterPort(SwarmCluster swarmCluster) {
    	int port = Integer.MIN_VALUE;
        
        try {
        	port = Integer.parseInt(swarmCluster.getPort());
        } catch (NumberFormatException e) {
            error("Port must be a valid integer.",
                    PasysPackage.Literals.SWARM_CLUSTER__PORT, INVALID_PORT_FORMAT);
        }
        
        if (port < MINIMUM_PORT || port > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.SWARM_CLUSTER__PORT, INVALID_PORT_VALUE);
        }
    }
    
    // Virtual Processing Node
    
    /**
     * Valida que el campo externalIP de VirtualProcessingNode cumpla con un patrón de IP correto
     * @param node
     */
    @Check
    public void checkVirtualProcessingNodeExternalIp(VirtualProcessingNode node) {
        String externalIP = node.getExternalIP();
        
        if (!externalIP.matches(IP_PATTERN)) {
        	error("Invalid IP address format. Expected format: xxx.xxx.xxx.xxx where each block is between 0-255",
					PasysPackage.Literals.VIRTUAL_PROCESSING_NODE__EXTERNAL_IP, INVALID_IP);
        }
    }
    
    // ZookeeperService
    
    /**
     * Valida que los campos "clientPort" "leaderPort" y "peerPort" de ZookeeperService sean un número entero comprendido entre 1024 y 65535 (ambos incluidos)
     * @param zookeeper
     */
    @Check
    public void checkZookeeperServiceValidPorts(ZookeeperService zookeeperService) {
    	int clientPort = 0, leaderPort = 0, peerPort = 0;

        try {
            clientPort = Integer.parseInt(zookeeperService.getClientPort());
        } catch (NumberFormatException e) {
            error("Client port must be a valid integer.",
                    PasysPackage.Literals.ZOOKEEPER_SERVICE__CLIENT_PORT, INVALID_PORT_FORMAT);
        }

        try {
            leaderPort = Integer.parseInt(zookeeperService.getLeaderPort());
        } catch (NumberFormatException e) {
            error("Leader port must be a valid integer.",
                    PasysPackage.Literals.ZOOKEEPER_SERVICE__LEADER_PORT, INVALID_PORT_FORMAT);
        }

        try {
            peerPort = Integer.parseInt(zookeeperService.getPeerPort());
        } catch (NumberFormatException e) {
            error("Peer port must be a valid integer.",
                    PasysPackage.Literals.ZOOKEEPER_SERVICE__PEER_PORT, INVALID_PORT_FORMAT);
        }
        
        if (clientPort < MINIMUM_PORT || clientPort > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.ZOOKEEPER_SERVICE__CLIENT_PORT, INVALID_PORT_VALUE);
        }
        if (leaderPort < MINIMUM_PORT || leaderPort > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.ZOOKEEPER_SERVICE__LEADER_PORT, INVALID_PORT_VALUE);
        }
        if (peerPort < MINIMUM_PORT || peerPort > MAXIMUM_PORT) {
            error("Port number should be between MINIMUM_PORT and MAXIMUM_PORT.", 
                    PasysPackage.Literals.ZOOKEEPER_SERVICE__PEER_PORT, INVALID_PORT_VALUE);
        }
        if (clientPort == leaderPort) {
        	error("clientPort and leaderPort should not be the same.",
        			PasysPackage.Literals.ZOOKEEPER_SERVICE__CLIENT_PORT, SAME_PORTS);
        }
        if (clientPort == peerPort) {
        	error("clientPort and peerPort should not be the same.",
        			PasysPackage.Literals.ZOOKEEPER_SERVICE__CLIENT_PORT, SAME_PORTS);
        }
        if (leaderPort == peerPort) {
        	error("leaderPort and peerPort should not be the same.",
        			PasysPackage.Literals.ZOOKEEPER_SERVICE__LEADER_PORT, SAME_PORTS);
        }
    }
    
    private void validateProperties(Properties properties, EStructuralFeature feature, String attributeName) {
        if (properties == null || properties.isEmpty()) {
            error(attributeName + " cannot be empty. Please provide a value",
                  feature, EMPTY_FIELD);
            return;
        }
        
        String rawPropertiesString = properties.toString().replaceAll("[{}]", "").replaceAll("\"", "");
        
        if (!rawPropertiesString.matches(PROPERTIES_PATTERN)) {
            error("Invalid " + attributeName + " format. Please provide a valid Properties string (e.g., key1=value1,key2=value2).",
                  feature, INVALID_PROPERTIES_PATTERN);
        }
    }

}

