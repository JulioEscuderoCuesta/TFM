/*
 * generated by Xtext 2.32.0
 */
package es.unican.istr.xtext.serializer;

import com.google.inject.Inject;
import es.unican.istr.pasys.pasys.AVROService;
import es.unican.istr.pasys.pasys.AWSVirtualProcessingNode;
import es.unican.istr.pasys.pasys.ArtifactDescriptor;
import es.unican.istr.pasys.pasys.CassandraService;
import es.unican.istr.pasys.pasys.CommunicationMeter;
import es.unican.istr.pasys.pasys.ComputationalSystem;
import es.unican.istr.pasys.pasys.DataCenter;
import es.unican.istr.pasys.pasys.DeploymentConstraints;
import es.unican.istr.pasys.pasys.DeploymentFileDescriptor;
import es.unican.istr.pasys.pasys.DerivedStreamData;
import es.unican.istr.pasys.pasys.ExporterData;
import es.unican.istr.pasys.pasys.KafkaFlowStreamData;
import es.unican.istr.pasys.pasys.KafkaService;
import es.unican.istr.pasys.pasys.KafkaWorkloadStreamData;
import es.unican.istr.pasys.pasys.KubernetesCluster;
import es.unican.istr.pasys.pasys.KubernetesDeploymentConf;
import es.unican.istr.pasys.pasys.MemSQLService;
import es.unican.istr.pasys.pasys.Neo4JService;
import es.unican.istr.pasys.pasys.Network;
import es.unican.istr.pasys.pasys.NetworkUtilization;
import es.unican.istr.pasys.pasys.NodeDeploymentConf;
import es.unican.istr.pasys.pasys.NodeResourceMeter;
import es.unican.istr.pasys.pasys.NodeScheduler;
import es.unican.istr.pasys.pasys.NomadCluster;
import es.unican.istr.pasys.pasys.NomadDeploymentConf;
import es.unican.istr.pasys.pasys.PasysPackage;
import es.unican.istr.pasys.pasys.PhysicalProcessingNode;
import es.unican.istr.pasys.pasys.Port;
import es.unican.istr.pasys.pasys.ProcessingNodeCluster;
import es.unican.istr.pasys.pasys.ProcessingNodeMemory;
import es.unican.istr.pasys.pasys.ProcessingNodeUtilization;
import es.unican.istr.pasys.pasys.PrometheusService;
import es.unican.istr.pasys.pasys.Rack;
import es.unican.istr.pasys.pasys.SchedulableSet;
import es.unican.istr.pasys.pasys.SparkService;
import es.unican.istr.pasys.pasys.StormNimbus;
import es.unican.istr.pasys.pasys.StormService;
import es.unican.istr.pasys.pasys.StormSupervisor;
import es.unican.istr.pasys.pasys.StormUI;
import es.unican.istr.pasys.pasys.StreamDataPartition;
import es.unican.istr.pasys.pasys.StreamDataRate;
import es.unican.istr.pasys.pasys.StreamRateMeter;
import es.unican.istr.pasys.pasys.SwarmCluster;
import es.unican.istr.pasys.pasys.SwarmDeploymentConf;
import es.unican.istr.pasys.pasys.Task;
import es.unican.istr.pasys.pasys.TaskExecutor;
import es.unican.istr.pasys.pasys.TaskProcessingAmount;
import es.unican.istr.pasys.pasys.TaskProcessingAmountMeter;
import es.unican.istr.pasys.pasys.Volume;
import es.unican.istr.pasys.pasys.Workflow;
import es.unican.istr.pasys.pasys.WorkflowLatency;
import es.unican.istr.pasys.pasys.WorkflowLatencyMeter;
import es.unican.istr.pasys.pasys.ZookeeperService;
import es.unican.istr.xtext.services.MyPasysGrammarAccess;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MyPasysSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyPasysGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PasysPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PasysPackage.AVRO_SERVICE:
				sequence_AVROService(context, (AVROService) semanticObject); 
				return; 
			case PasysPackage.AWS_VIRTUAL_PROCESSING_NODE:
				sequence_AWSVirtualProcessingNode(context, (AWSVirtualProcessingNode) semanticObject); 
				return; 
			case PasysPackage.ARTIFACT_DESCRIPTOR:
				sequence_ArtifactDescriptor(context, (ArtifactDescriptor) semanticObject); 
				return; 
			case PasysPackage.CASSANDRA_SERVICE:
				sequence_CassandraService(context, (CassandraService) semanticObject); 
				return; 
			case PasysPackage.COMMUNICATION_METER:
				sequence_CommunicationMeter(context, (CommunicationMeter) semanticObject); 
				return; 
			case PasysPackage.COMPUTATIONAL_SYSTEM:
				sequence_ComputationalSystem(context, (ComputationalSystem) semanticObject); 
				return; 
			case PasysPackage.DATA_CENTER:
				sequence_DataCenter(context, (DataCenter) semanticObject); 
				return; 
			case PasysPackage.DEPLOYMENT_CONSTRAINTS:
				sequence_DeploymentConstraints(context, (DeploymentConstraints) semanticObject); 
				return; 
			case PasysPackage.DEPLOYMENT_FILE_DESCRIPTOR:
				sequence_DeploymentFileDescriptor(context, (DeploymentFileDescriptor) semanticObject); 
				return; 
			case PasysPackage.DERIVED_STREAM_DATA:
				sequence_DerivedStreamData(context, (DerivedStreamData) semanticObject); 
				return; 
			case PasysPackage.EXPORTER_DATA:
				sequence_ExporterData(context, (ExporterData) semanticObject); 
				return; 
			case PasysPackage.KAFKA_FLOW_STREAM_DATA:
				sequence_KafkaFlowStreamData(context, (KafkaFlowStreamData) semanticObject); 
				return; 
			case PasysPackage.KAFKA_SERVICE:
				sequence_KafkaService(context, (KafkaService) semanticObject); 
				return; 
			case PasysPackage.KAFKA_WORKLOAD_STREAM_DATA:
				sequence_KafkaWorkloadStreamData(context, (KafkaWorkloadStreamData) semanticObject); 
				return; 
			case PasysPackage.KUBERNETES_CLUSTER:
				sequence_KubernetesCluster(context, (KubernetesCluster) semanticObject); 
				return; 
			case PasysPackage.KUBERNETES_DEPLOYMENT_CONF:
				sequence_KubernetesDeploymentConf(context, (KubernetesDeploymentConf) semanticObject); 
				return; 
			case PasysPackage.MEM_SQL_SERVICE:
				sequence_MemSQLService(context, (MemSQLService) semanticObject); 
				return; 
			case PasysPackage.NEO4_JSERVICE:
				sequence_Neo4JService(context, (Neo4JService) semanticObject); 
				return; 
			case PasysPackage.NETWORK:
				sequence_Network(context, (Network) semanticObject); 
				return; 
			case PasysPackage.NETWORK_UTILIZATION:
				sequence_NetworkUtilization(context, (NetworkUtilization) semanticObject); 
				return; 
			case PasysPackage.NODE_DEPLOYMENT_CONF:
				sequence_NodeDeploymentConf(context, (NodeDeploymentConf) semanticObject); 
				return; 
			case PasysPackage.NODE_RESOURCE_METER:
				sequence_NodeResourceMeter(context, (NodeResourceMeter) semanticObject); 
				return; 
			case PasysPackage.NODE_SCHEDULER:
				sequence_NodeScheduler(context, (NodeScheduler) semanticObject); 
				return; 
			case PasysPackage.NOMAD_CLUSTER:
				sequence_NomadCluster(context, (NomadCluster) semanticObject); 
				return; 
			case PasysPackage.NOMAD_DEPLOYMENT_CONF:
				sequence_NomadDeploymentConf(context, (NomadDeploymentConf) semanticObject); 
				return; 
			case PasysPackage.PHYSICAL_PROCESSING_NODE:
				sequence_PhysicalProcessingNode(context, (PhysicalProcessingNode) semanticObject); 
				return; 
			case PasysPackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case PasysPackage.PROCESSING_NODE_CLUSTER:
				sequence_ProcessingNodeCluster(context, (ProcessingNodeCluster) semanticObject); 
				return; 
			case PasysPackage.PROCESSING_NODE_MEMORY:
				sequence_ProcessingNodeMemory(context, (ProcessingNodeMemory) semanticObject); 
				return; 
			case PasysPackage.PROCESSING_NODE_UTILIZATION:
				sequence_ProcessingNodeUtilization(context, (ProcessingNodeUtilization) semanticObject); 
				return; 
			case PasysPackage.PROMETHEUS_SERVICE:
				sequence_PrometheusService(context, (PrometheusService) semanticObject); 
				return; 
			case PasysPackage.RACK:
				sequence_Rack(context, (Rack) semanticObject); 
				return; 
			case PasysPackage.SCHEDULABLE_SET:
				sequence_SchedulableSet(context, (SchedulableSet) semanticObject); 
				return; 
			case PasysPackage.SPARK_SERVICE:
				sequence_SparkService(context, (SparkService) semanticObject); 
				return; 
			case PasysPackage.STORM_NIMBUS:
				sequence_StormNimbus(context, (StormNimbus) semanticObject); 
				return; 
			case PasysPackage.STORM_SERVICE:
				sequence_StormService(context, (StormService) semanticObject); 
				return; 
			case PasysPackage.STORM_SUPERVISOR:
				sequence_StormSupervisor(context, (StormSupervisor) semanticObject); 
				return; 
			case PasysPackage.STORM_UI:
				sequence_StormUI(context, (StormUI) semanticObject); 
				return; 
			case PasysPackage.STREAM_DATA_PARTITION:
				sequence_StreamDataPartition(context, (StreamDataPartition) semanticObject); 
				return; 
			case PasysPackage.STREAM_DATA_RATE:
				sequence_StreamDataRate(context, (StreamDataRate) semanticObject); 
				return; 
			case PasysPackage.STREAM_RATE_METER:
				sequence_StreamRateMeter(context, (StreamRateMeter) semanticObject); 
				return; 
			case PasysPackage.STRING_TO_STRING_MAP:
				sequence_StringToStringMap(context, (Map.Entry) semanticObject); 
				return; 
			case PasysPackage.SWARM_CLUSTER:
				sequence_SwarmCluster(context, (SwarmCluster) semanticObject); 
				return; 
			case PasysPackage.SWARM_DEPLOYMENT_CONF:
				sequence_SwarmDeploymentConf(context, (SwarmDeploymentConf) semanticObject); 
				return; 
			case PasysPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case PasysPackage.TASK_EXECUTOR:
				sequence_TaskExecutor(context, (TaskExecutor) semanticObject); 
				return; 
			case PasysPackage.TASK_PROCESSING_AMOUNT:
				sequence_TaskProcessingAmount(context, (TaskProcessingAmount) semanticObject); 
				return; 
			case PasysPackage.TASK_PROCESSING_AMOUNT_METER:
				sequence_TaskProcessingAmountMeter(context, (TaskProcessingAmountMeter) semanticObject); 
				return; 
			case PasysPackage.VOLUME:
				sequence_Volume(context, (Volume) semanticObject); 
				return; 
			case PasysPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			case PasysPackage.WORKFLOW_LATENCY:
				sequence_WorkflowLatency(context, (WorkflowLatency) semanticObject); 
				return; 
			case PasysPackage.WORKFLOW_LATENCY_METER:
				sequence_WorkflowLatencyMeter(context, (WorkflowLatencyMeter) semanticObject); 
				return; 
			case PasysPackage.ZOOKEEPER_SERVICE:
				sequence_ZookeeperService(context, (ZookeeperService) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns AVROService
	 *     AVROService returns AVROService
	 *
	 * Constraint:
	 *     (name=EString id=EString host=[ProcessingResourceCluster|EString] deploymentConfig=DeploymentConfiguration)
	 * </pre>
	 */
	protected void sequence_AVROService(ISerializationContext context, AVROService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PLATFORM_SERVICE__HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PLATFORM_SERVICE__HOST));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAVROServiceAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAVROServiceAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getAVROServiceAccess().getHostProcessingResourceClusterEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.PLATFORM_SERVICE__HOST, false));
		feeder.accept(grammarAccess.getAVROServiceAccess().getDeploymentConfigDeploymentConfigurationParserRuleCall_8_0(), semanticObject.getDeploymentConfig());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns AWSVirtualProcessingNode
	 *     ProcessingNode returns AWSVirtualProcessingNode
	 *     AWSVirtualProcessingNode returns AWSVirtualProcessingNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         ip=EString 
	 *         speedFactor=EDouble 
	 *         userName=EString 
	 *         externalIP=EString 
	 *         keyPair=EString 
	 *         AMI=EString? 
	 *         (codeFiles+=ArtifactDescriptor codeFiles+=ArtifactDescriptor*)? 
	 *         concurrencyLevel=EInt? 
	 *         configData=Properties? 
	 *         (configFiles+=DeploymentFileDescriptor configFiles+=DeploymentFileDescriptor*)? 
	 *         (connectedTo+=[Network|EString] connectedTo+=[Network|EString]*)? 
	 *         instanceType=EString? 
	 *         (launchingScripts+=DeploymentFileDescriptor launchingScripts+=DeploymentFileDescriptor*)? 
	 *         memorySize=EInt? 
	 *         os=EString? 
	 *         (ownedMeters+=NodeHostedMeter ownedMeters+=NodeHostedMeter*)? 
	 *         securityGroup=EString? 
	 *         subNet=EString? 
	 *         vpc=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_AWSVirtualProcessingNode(ISerializationContext context, AWSVirtualProcessingNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FileDescriptor returns ArtifactDescriptor
	 *     ArtifactDescriptor returns ArtifactDescriptor
	 *
	 * Constraint:
	 *     (fileName=EString filePath=EString localPath=EString)
	 * </pre>
	 */
	protected void sequence_ArtifactDescriptor(ISerializationContext context, ArtifactDescriptor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.FILE_DESCRIPTOR__FILE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.FILE_DESCRIPTOR__FILE_NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.FILE_DESCRIPTOR__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.FILE_DESCRIPTOR__FILE_PATH));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ARTIFACT_DESCRIPTOR__LOCAL_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ARTIFACT_DESCRIPTOR__LOCAL_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArtifactDescriptorAccess().getFileNameEStringParserRuleCall_3_0(), semanticObject.getFileName());
		feeder.accept(grammarAccess.getArtifactDescriptorAccess().getFilePathEStringParserRuleCall_5_0(), semanticObject.getFilePath());
		feeder.accept(grammarAccess.getArtifactDescriptorAccess().getLocalPathEStringParserRuleCall_7_0(), semanticObject.getLocalPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns CassandraService
	 *     CassandraService returns CassandraService
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         logging=EString 
	 *         passwd=EString 
	 *         port=EInt 
	 *         autoBootstrap=EBoolean 
	 *         numTokens=EInt 
	 *         dataFileDir=EString 
	 *         storagePort=EString 
	 *         sslStoragePort=EString 
	 *         rpcPort=EString 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         dataCenters+=DataCenter 
	 *         dataCenters+=DataCenter* 
	 *         (cqlSchemas+=FileDescriptor cqlSchemas+=FileDescriptor*)? 
	 *         endpointSnitch=EString? 
	 *         seeds=[ProcessingNodeCluster|EString]? 
	 *         seedProviderClass=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_CassandraService(ISerializationContext context, CassandraService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeHostedMeter returns CommunicationMeter
	 *     Meter returns CommunicationMeter
	 *     CommunicationMeter returns CommunicationMeter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         metric=[NetworkUtilization|EString] 
	 *         monitoringPort=EString 
	 *         monitoringTime=ELong 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         monitoringServer=[MonitoringService|EString]?
	 *     )
	 * </pre>
	 */
	protected void sequence_CommunicationMeter(ISerializationContext context, CommunicationMeter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ComputationalSystem returns ComputationalSystem
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         date=EString 
	 *         authors=EString? 
	 *         ownedElements+=SystemElement 
	 *         ownedElements+=SystemElement* 
	 *         targetPlatformName=EString? 
	 *         doc=EString? 
	 *         (authenticationFiles+=StringToStringMap authenticationFiles+=StringToStringMap*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ComputationalSystem(ISerializationContext context, ComputationalSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataCenter returns DataCenter
	 *
	 * Constraint:
	 *     (name=EString id=EString racks+=Rack racks+=Rack*)
	 * </pre>
	 */
	protected void sequence_DataCenter(ISerializationContext context, DataCenter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeploymentConstraints returns DeploymentConstraints
	 *
	 * Constraint:
	 *     (labels=Properties? resources=Properties?)
	 * </pre>
	 */
	protected void sequence_DeploymentConstraints(ISerializationContext context, DeploymentConstraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FileDescriptor returns DeploymentFileDescriptor
	 *     DeploymentFileDescriptor returns DeploymentFileDescriptor
	 *
	 * Constraint:
	 *     (fileContent=EString fileName=EString filePath=EString elementType=DeployableComponentType? owner=[ProcessingNode|EString]?)
	 * </pre>
	 */
	protected void sequence_DeploymentFileDescriptor(ISerializationContext context, DeploymentFileDescriptor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StreamData returns DerivedStreamData
	 *     WorkflowStreamData returns DerivedStreamData
	 *     DerivedStreamData returns DerivedStreamData
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         numPartitions=EInt 
	 *         numReplication=EInt 
	 *         retention_ms=ELong 
	 *         retention_bytes=EInt 
	 *         cleanupPolicy=EBoolean 
	 *         inputs+=[StreamData|EString] 
	 *         inputs+=[StreamData|EString]* 
	 *         isSingleUse=EBoolean 
	 *         messageSize=EInt 
	 *         pattern=EString 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         (assignedPartition+=StreamDataPartition assignedPartition+=StreamDataPartition*)? 
	 *         (ownedMeters+=StreamRateMeter ownedMeters+=StreamRateMeter*)? 
	 *         schemaFile=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_DerivedStreamData(ISerializationContext context, DerivedStreamData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExporterData returns ExporterData
	 *
	 * Constraint:
	 *     (name=EString artifact=EString)
	 * </pre>
	 */
	protected void sequence_ExporterData(ISerializationContext context, ExporterData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.EXPORTER_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.EXPORTER_DATA__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.EXPORTER_DATA__ARTIFACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.EXPORTER_DATA__ARTIFACT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExporterDataAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExporterDataAccess().getArtifactEStringParserRuleCall_4_0(), semanticObject.getArtifact());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StreamData returns KafkaFlowStreamData
	 *     WorkflowStreamData returns KafkaFlowStreamData
	 *     FlowStreamData returns KafkaFlowStreamData
	 *     KafkaFlowStreamData returns KafkaFlowStreamData
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         numPartitions=EInt 
	 *         numReplication=EInt 
	 *         retention_ms=ELong 
	 *         retention_bytes=EInt 
	 *         cleanupPolicy=EBoolean 
	 *         isImplemented=EBoolean 
	 *         isSingleUse=EBoolean 
	 *         messageSize=EInt 
	 *         predecessor=[StreamData|EString] 
	 *         source=[StreamData|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         (assignedPartition+=StreamDataPartition assignedPartition+=StreamDataPartition*)? 
	 *         holder=[CommunicationService|EString]? 
	 *         (ownedMeters+=StreamRateMeter ownedMeters+=StreamRateMeter*)? 
	 *         schemaFile=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_KafkaFlowStreamData(ISerializationContext context, KafkaFlowStreamData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns KafkaService
	 *     CommunicationService returns KafkaService
	 *     KafkaService returns KafkaService
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         commId=EInt 
	 *         id=EString 
	 *         clientPort=EString 
	 *         autoCreateTopicEnable=EBoolean 
	 *         deleteTopicEnable=EBoolean 
	 *         zookeeperConnect=[ZookeeperService|EString] 
	 *         zookeeperConnectionTimeout=EInt 
	 *         numPartitions=EInt 
	 *         numRecoveryThreadsPerDataDir=EInt 
	 *         logFlushInterval=EInt 
	 *         logFlushIntervalMessages=EInt 
	 *         numIOThreads=EInt 
	 *         numNetworkThreads=EInt 
	 *         socketReceiveBufferBytes=EInt 
	 *         socketRequestMaxBytes=EInt 
	 *         socketSendBufferBytes=EInt 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         advertisedListeners=EString? 
	 *         listeners=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_KafkaService(ISerializationContext context, KafkaService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns KafkaWorkloadStreamData
	 *     StreamData returns KafkaWorkloadStreamData
	 *     WorkloadStreamData returns KafkaWorkloadStreamData
	 *     KafkaWorkloadStreamData returns KafkaWorkloadStreamData
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         cleanupPolicy=EBoolean 
	 *         retention_ms=ELong 
	 *         retention_bytes=EInt 
	 *         numPartitions=EInt 
	 *         numReplication=EInt 
	 *         messageSize=EInt 
	 *         holder=[CommunicationService|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         (assignedPartition+=StreamDataPartition assignedPartition+=StreamDataPartition*)? 
	 *         (ownedMeters+=StreamRateMeter ownedMeters+=StreamRateMeter*)? 
	 *         schemaFile=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_KafkaWorkloadStreamData(ISerializationContext context, KafkaWorkloadStreamData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns KubernetesCluster
	 *     ProcessingResourceCluster returns KubernetesCluster
	 *     KubernetesCluster returns KubernetesCluster
	 *
	 * Constraint:
	 *     (name=EString id=EString kubeConfigPath=EString apiVersion=EString?)
	 * </pre>
	 */
	protected void sequence_KubernetesCluster(ISerializationContext context, KubernetesCluster semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeploymentConfiguration returns KubernetesDeploymentConf
	 *     KubernetesDeploymentConf returns KubernetesDeploymentConf
	 *
	 * Constraint:
	 *     (
	 *         image=EString 
	 *         replicas=EInt 
	 *         args=EString? 
	 *         command=EString? 
	 *         constraints=DeploymentConstraints? 
	 *         env=Properties? 
	 *         externalIP=EString? 
	 *         imagePullPolicy=EString? 
	 *         imageTag=EString? 
	 *         (ports+=Port ports+=Port*)? 
	 *         restartPolicy=EString? 
	 *         serviceType=ServiceType? 
	 *         (volumes+=Volume volumes+=Volume*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_KubernetesDeploymentConf(ISerializationContext context, KubernetesDeploymentConf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns MemSQLService
	 *     MemSQLService returns MemSQLService
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         logging=EString 
	 *         passwd=EString 
	 *         port=EInt 
	 *         deploymentConfig=DeploymentConfiguration
	 *     )
	 * </pre>
	 */
	protected void sequence_MemSQLService(ISerializationContext context, MemSQLService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PLATFORM_SERVICE__HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PLATFORM_SERVICE__HOST));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__LOGGING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__LOGGING));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__PASSWD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__PASSWD));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__PORT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMemSQLServiceAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMemSQLServiceAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getMemSQLServiceAccess().getHostProcessingResourceClusterEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.PLATFORM_SERVICE__HOST, false));
		feeder.accept(grammarAccess.getMemSQLServiceAccess().getLoggingEStringParserRuleCall_8_0(), semanticObject.getLogging());
		feeder.accept(grammarAccess.getMemSQLServiceAccess().getPasswdEStringParserRuleCall_10_0(), semanticObject.getPasswd());
		feeder.accept(grammarAccess.getMemSQLServiceAccess().getPortEIntParserRuleCall_12_0(), semanticObject.getPort());
		feeder.accept(grammarAccess.getMemSQLServiceAccess().getDeploymentConfigDeploymentConfigurationParserRuleCall_14_0(), semanticObject.getDeploymentConfig());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns Neo4JService
	 *     Neo4JService returns Neo4JService
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         logging=EString 
	 *         passwd=EString 
	 *         port=EInt 
	 *         deploymentConfig=DeploymentConfiguration
	 *     )
	 * </pre>
	 */
	protected void sequence_Neo4JService(ISerializationContext context, Neo4JService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PLATFORM_SERVICE__HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PLATFORM_SERVICE__HOST));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__LOGGING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__LOGGING));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__PASSWD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__PASSWD));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PERSISTENCE_SERVICE__PORT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNeo4JServiceAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNeo4JServiceAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getNeo4JServiceAccess().getHostProcessingResourceClusterEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.PLATFORM_SERVICE__HOST, false));
		feeder.accept(grammarAccess.getNeo4JServiceAccess().getLoggingEStringParserRuleCall_8_0(), semanticObject.getLogging());
		feeder.accept(grammarAccess.getNeo4JServiceAccess().getPasswdEStringParserRuleCall_10_0(), semanticObject.getPasswd());
		feeder.accept(grammarAccess.getNeo4JServiceAccess().getPortEIntParserRuleCall_12_0(), semanticObject.getPort());
		feeder.accept(grammarAccess.getNeo4JServiceAccess().getDeploymentConfigDeploymentConfigurationParserRuleCall_14_0(), semanticObject.getDeploymentConfig());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns NetworkUtilization
	 *     NetworkUtilization returns NetworkUtilization
	 *
	 * Constraint:
	 *     (name=EString id=EString target=[Network|EString])
	 * </pre>
	 */
	protected void sequence_NetworkUtilization(ISerializationContext context, NetworkUtilization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NETWORK_UTILIZATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NETWORK_UTILIZATION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNetworkUtilizationAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNetworkUtilizationAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getNetworkUtilizationAccess().getTargetNetworkEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.NETWORK_UTILIZATION__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns Network
	 *     Network returns Network
	 *
	 * Constraint:
	 *     (name=EString id=EString bandwith=EDouble)
	 * </pre>
	 */
	protected void sequence_Network(ISerializationContext context, Network semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NETWORK__BANDWITH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NETWORK__BANDWITH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNetworkAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNetworkAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getNetworkAccess().getBandwithEDoubleParserRuleCall_6_0(), semanticObject.getBandwith());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeploymentConfiguration returns NodeDeploymentConf
	 *     NodeDeploymentConf returns NodeDeploymentConf
	 *
	 * Constraint:
	 *     (
	 *         artifactName=EString 
	 *         isRunning=EBoolean 
	 *         (arguments+=EString arguments+=EString*)? 
	 *         artifactLocator=EString? 
	 *         codeFolderPath=EString? 
	 *         configFolderPath=EString? 
	 *         dataFolderPath=EString? 
	 *         logFolderPath=EString? 
	 *         scriptFolderPath=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_NodeDeploymentConf(ISerializationContext context, NodeDeploymentConf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeHostedMeter returns NodeResourceMeter
	 *     Meter returns NodeResourceMeter
	 *     NodeResourceMeter returns NodeResourceMeter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         monitoringPort=EString 
	 *         monitoringTime=ELong 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         mMetric=[ProcessingNodeMemory|ID]? 
	 *         monitoringServer=[MonitoringService|EString]? 
	 *         uMetric=[ProcessingNodeUtilization|ID]?
	 *     )
	 * </pre>
	 */
	protected void sequence_NodeResourceMeter(ISerializationContext context, NodeResourceMeter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns NodeScheduler
	 *     SchedulingService returns NodeScheduler
	 *     NodeScheduler returns NodeScheduler
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         (workflows+=[Workflow|EString] workflows+=[Workflow|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_NodeScheduler(ISerializationContext context, NodeScheduler semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns NomadCluster
	 *     ProcessingResourceCluster returns NomadCluster
	 *     NomadCluster returns NomadCluster
	 *
	 * Constraint:
	 *     (name=EString id=EString ip=EString port=EString)
	 * </pre>
	 */
	protected void sequence_NomadCluster(ISerializationContext context, NomadCluster semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NOMAD_CLUSTER__IP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NOMAD_CLUSTER__IP));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NOMAD_CLUSTER__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NOMAD_CLUSTER__PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNomadClusterAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNomadClusterAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getNomadClusterAccess().getIpEStringParserRuleCall_6_0(), semanticObject.getIp());
		feeder.accept(grammarAccess.getNomadClusterAccess().getPortEStringParserRuleCall_8_0(), semanticObject.getPort());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeploymentConfiguration returns NomadDeploymentConf
	 *     NomadDeploymentConf returns NomadDeploymentConf
	 *
	 * Constraint:
	 *     (
	 *         imageTag=EString? 
	 *         image=EString 
	 *         priority=EInt 
	 *         region=EString 
	 *         dataCenter=EString 
	 *         replicas=EInt 
	 *         args=EString? 
	 *         command=EString? 
	 *         constraints=DeploymentConstraints? 
	 *         driver=NomadDriver? 
	 *         env=Properties? 
	 *         imagePullPolicy=EString? 
	 *         (ports+=Port ports+=Port*)? 
	 *         restartPolicy=EString? 
	 *         (volumes+=Volume volumes+=Volume*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_NomadDeploymentConf(ISerializationContext context, NomadDeploymentConf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns PhysicalProcessingNode
	 *     ProcessingNode returns PhysicalProcessingNode
	 *     PhysicalProcessingNode returns PhysicalProcessingNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         ip=EString 
	 *         speedFactor=EDouble 
	 *         userName=EString 
	 *         (codeFiles+=ArtifactDescriptor codeFiles+=ArtifactDescriptor*)? 
	 *         concurrencyLevel=EInt? 
	 *         configData=Properties? 
	 *         (configFiles+=DeploymentFileDescriptor configFiles+=DeploymentFileDescriptor*)? 
	 *         (connectedTo+=[Network|EString] connectedTo+=[Network|EString]*)? 
	 *         (launchingScripts+=DeploymentFileDescriptor launchingScripts+=DeploymentFileDescriptor*)? 
	 *         memorySize=EInt? 
	 *         os=EString? 
	 *         (ownedMeters+=NodeHostedMeter ownedMeters+=NodeHostedMeter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicalProcessingNode(ISerializationContext context, PhysicalProcessingNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Port returns Port
	 *
	 * Constraint:
	 *     (published=EString target=EString)
	 * </pre>
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PORT__PUBLISHED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PORT__PUBLISHED));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PORT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PORT__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortAccess().getPublishedEStringParserRuleCall_3_0(), semanticObject.getPublished());
		feeder.accept(grammarAccess.getPortAccess().getTargetEStringParserRuleCall_5_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns ProcessingNodeCluster
	 *     ProcessingResourceCluster returns ProcessingNodeCluster
	 *     ProcessingNodeCluster returns ProcessingNodeCluster
	 *
	 * Constraint:
	 *     (name=EString id=EString nodes+=[ProcessingNode|EString] nodes+=[ProcessingNode|EString]*)
	 * </pre>
	 */
	protected void sequence_ProcessingNodeCluster(ISerializationContext context, ProcessingNodeCluster semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns ProcessingNodeMemory
	 *     ProcessingNodeMemory returns ProcessingNodeMemory
	 *
	 * Constraint:
	 *     (name=EString id=EString target=[ProcessingNode|EString])
	 * </pre>
	 */
	protected void sequence_ProcessingNodeMemory(ISerializationContext context, ProcessingNodeMemory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PROCESSING_NODE_MEMORY__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PROCESSING_NODE_MEMORY__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessingNodeMemoryAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProcessingNodeMemoryAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getProcessingNodeMemoryAccess().getTargetProcessingNodeEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.PROCESSING_NODE_MEMORY__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns ProcessingNodeUtilization
	 *     ProcessingNodeUtilization returns ProcessingNodeUtilization
	 *
	 * Constraint:
	 *     (name=EString id=EString target=[ProcessingNode|EString])
	 * </pre>
	 */
	protected void sequence_ProcessingNodeUtilization(ISerializationContext context, ProcessingNodeUtilization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PROCESSING_NODE_UTILIZATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PROCESSING_NODE_UTILIZATION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessingNodeUtilizationAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProcessingNodeUtilizationAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getProcessingNodeUtilizationAccess().getTargetProcessingNodeEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.PROCESSING_NODE_UTILIZATION__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns PrometheusService
	 *     MonitoringService returns PrometheusService
	 *     PrometheusService returns PrometheusService
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         (exportersData+=ExporterData exportersData+=ExporterData*)? 
	 *         (monitorizedMeters+=[Meter|EString] monitorizedMeters+=[Meter|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_PrometheusService(ISerializationContext context, PrometheusService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Rack returns Rack
	 *
	 * Constraint:
	 *     (name=EString id=EString nodes=[ProcessingNodeCluster|EString])
	 * </pre>
	 */
	protected void sequence_Rack(ISerializationContext context, Rack semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.RACK__NODES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.RACK__NODES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRackAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRackAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getRackAccess().getNodesProcessingNodeClusterEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.RACK__NODES, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns SchedulableSet
	 *     SchedulableSet returns SchedulableSet
	 *
	 * Constraint:
	 *     (name=EString id=EString workflows+=[Workflow|EString] workflows+=[Workflow|EString]*)
	 * </pre>
	 */
	protected void sequence_SchedulableSet(ISerializationContext context, SchedulableSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns SparkService
	 *     SchedulingService returns SparkService
	 *     SparkService returns SparkService
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         driverCores=EInt 
	 *         driverMemory=ELong 
	 *         driverSuperviser=EBoolean 
	 *         executorMemory=ELong 
	 *         logCallerContext=EString 
	 *         logConf=EBoolean 
	 *         load=[SchedulableSet|EString] 
	 *         master=[ProcessingResourceCluster|EString] 
	 *         windowSize=EInt 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         driverMaxResultSize=EString? 
	 *         extraListener=EString? 
	 *         localDir=EString? 
	 *         submitDeployMode=EString? 
	 *         (workflows+=[Workflow|EString] workflows+=[Workflow|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_SparkService(ISerializationContext context, SparkService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StormNimbus returns StormNimbus
	 *
	 * Constraint:
	 *     (name=EString id=EString deploymentConfig=DeploymentConfiguration host=[ProcessingResourceCluster|EString]?)
	 * </pre>
	 */
	protected void sequence_StormNimbus(ISerializationContext context, StormNimbus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns StormService
	 *     SchedulingService returns StormService
	 *     StormService returns StormService
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         zookeeperConnect=[ZookeeperService|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         nimbus=StormNimbus 
	 *         supervisor=StormSupervisor 
	 *         localDir=EString? 
	 *         ui=StormUI? 
	 *         (workflows+=[Workflow|EString] workflows+=[Workflow|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_StormService(ISerializationContext context, StormService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StormSupervisor returns StormSupervisor
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         host=[ProcessingResourceCluster|EString]? 
	 *         (supervisorSlotPorts+=EString supervisorSlotPorts+=EString*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_StormSupervisor(ISerializationContext context, StormSupervisor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StormUI returns StormUI
	 *
	 * Constraint:
	 *     (name=EString id=EString uiPort=EString deploymentConfig=DeploymentConfiguration host=[ProcessingResourceCluster|EString]?)
	 * </pre>
	 */
	protected void sequence_StormUI(ISerializationContext context, StormUI semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StreamDataPartition returns StreamDataPartition
	 *
	 * Constraint:
	 *     (host=[ProcessingNode|EString] key=EString?)
	 * </pre>
	 */
	protected void sequence_StreamDataPartition(ISerializationContext context, StreamDataPartition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns StreamDataRate
	 *     StreamDataRate returns StreamDataRate
	 *
	 * Constraint:
	 *     (name=EString id=EString target=[StreamData|EString])
	 * </pre>
	 */
	protected void sequence_StreamDataRate(ISerializationContext context, StreamDataRate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.STREAM_DATA_RATE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.STREAM_DATA_RATE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStreamDataRateAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStreamDataRateAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getStreamDataRateAccess().getTargetStreamDataEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.STREAM_DATA_RATE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Meter returns StreamRateMeter
	 *     StreamRateMeter returns StreamRateMeter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         monitoringPort=EString 
	 *         monitoringTime=ELong 
	 *         metric=[StreamDataRate|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         monitoringServer=[MonitoringService|EString]?
	 *     )
	 * </pre>
	 */
	protected void sequence_StreamRateMeter(ISerializationContext context, StreamRateMeter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringToStringMap returns StringToStringMap
	 *
	 * Constraint:
	 *     (key=EString value=EString)
	 * </pre>
	 */
	protected void sequence_StringToStringMap(ISerializationContext context, Map.Entry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, PasysPackage.Literals.STRING_TO_STRING_MAP__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, PasysPackage.Literals.STRING_TO_STRING_MAP__KEY));
			if (transientValues.isValueTransient((EObject) semanticObject, PasysPackage.Literals.STRING_TO_STRING_MAP__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, PasysPackage.Literals.STRING_TO_STRING_MAP__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getStringToStringMapAccess().getKeyEStringParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getStringToStringMapAccess().getValueEStringParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns SwarmCluster
	 *     ProcessingResourceCluster returns SwarmCluster
	 *     SwarmCluster returns SwarmCluster
	 *
	 * Constraint:
	 *     (name=EString id=EString ip=EString port=EString user=EString)
	 * </pre>
	 */
	protected void sequence_SwarmCluster(ISerializationContext context, SwarmCluster semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.SWARM_CLUSTER__IP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.SWARM_CLUSTER__IP));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.SWARM_CLUSTER__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.SWARM_CLUSTER__PORT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.SWARM_CLUSTER__USER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.SWARM_CLUSTER__USER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwarmClusterAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSwarmClusterAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getSwarmClusterAccess().getIpEStringParserRuleCall_6_0(), semanticObject.getIp());
		feeder.accept(grammarAccess.getSwarmClusterAccess().getPortEStringParserRuleCall_8_0(), semanticObject.getPort());
		feeder.accept(grammarAccess.getSwarmClusterAccess().getUserEStringParserRuleCall_10_0(), semanticObject.getUser());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeploymentConfiguration returns SwarmDeploymentConf
	 *     SwarmDeploymentConf returns SwarmDeploymentConf
	 *
	 * Constraint:
	 *     (
	 *         imageTag=EString? 
	 *         image=EString 
	 *         replicas=EInt 
	 *         args=EString? 
	 *         command=EString? 
	 *         constraints=DeploymentConstraints? 
	 *         env=Properties? 
	 *         imagePullPolicy=EString? 
	 *         (network+=EString network+=EString*)? 
	 *         (ports+=Port ports+=Port*)? 
	 *         restartPolicy=EString? 
	 *         (volumes+=Volume volumes+=Volume*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_SwarmDeploymentConf(ISerializationContext context, SwarmDeploymentConf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TaskExecutor returns TaskExecutor
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         executedTasks+=[Task|EString] 
	 *         executedTasks+=[Task|EString]* 
	 *         (ownedMeters+=TaskProcessingAmountMeter ownedMeters+=TaskProcessingAmountMeter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_TaskExecutor(ISerializationContext context, TaskExecutor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Meter returns TaskProcessingAmountMeter
	 *     TaskProcessingAmountMeter returns TaskProcessingAmountMeter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         metric=[TaskProcessingAmount|EString] 
	 *         monitoringPort=EString 
	 *         monitoringTime=ELong 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         monitoringServer=[MonitoringService|EString]
	 *     )
	 * </pre>
	 */
	protected void sequence_TaskProcessingAmountMeter(ISerializationContext context, TaskProcessingAmountMeter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT_METER__METRIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT_METER__METRIC));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PROMETHEUS_METER__MONITORING_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PROMETHEUS_METER__MONITORING_PORT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PROMETHEUS_METER__MONITORING_TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PROMETHEUS_METER__MONITORING_TIME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.METER__MONITORING_SERVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.METER__MONITORING_SERVER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskProcessingAmountMeterAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTaskProcessingAmountMeterAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getTaskProcessingAmountMeterAccess().getMetricTaskProcessingAmountEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.TASK_PROCESSING_AMOUNT_METER__METRIC, false));
		feeder.accept(grammarAccess.getTaskProcessingAmountMeterAccess().getMonitoringPortEStringParserRuleCall_8_0(), semanticObject.getMonitoringPort());
		feeder.accept(grammarAccess.getTaskProcessingAmountMeterAccess().getMonitoringTimeELongParserRuleCall_10_0(), semanticObject.getMonitoringTime());
		feeder.accept(grammarAccess.getTaskProcessingAmountMeterAccess().getDeploymentConfigDeploymentConfigurationParserRuleCall_12_0(), semanticObject.getDeploymentConfig());
		feeder.accept(grammarAccess.getTaskProcessingAmountMeterAccess().getMonitoringServerMonitoringServiceEStringParserRuleCall_14_0_1(), semanticObject.eGet(PasysPackage.Literals.METER__MONITORING_SERVER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns TaskProcessingAmount
	 *     TaskProcessingAmount returns TaskProcessingAmount
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         target=[Task|EString] 
	 *         histogramBuckectNum=EInt 
	 *         expectedMaxTPA=ELong 
	 *         expectedMinTPA=ELong 
	 *         linearBucketDistribution=EBoolean
	 *     )
	 * </pre>
	 */
	protected void sequence_TaskProcessingAmount(ISerializationContext context, TaskProcessingAmount semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__TARGET));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__HISTOGRAM_BUCKECT_NUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__HISTOGRAM_BUCKECT_NUM));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__EXPECTED_MAX_TPA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__EXPECTED_MAX_TPA));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__EXPECTED_MIN_TPA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__EXPECTED_MIN_TPA));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__LINEAR_BUCKET_DISTRIBUTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.TASK_PROCESSING_AMOUNT__LINEAR_BUCKET_DISTRIBUTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskProcessingAmountAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTaskProcessingAmountAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getTaskProcessingAmountAccess().getTargetTaskEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.TASK_PROCESSING_AMOUNT__TARGET, false));
		feeder.accept(grammarAccess.getTaskProcessingAmountAccess().getHistogramBuckectNumEIntParserRuleCall_8_0(), semanticObject.getHistogramBuckectNum());
		feeder.accept(grammarAccess.getTaskProcessingAmountAccess().getExpectedMaxTPAELongParserRuleCall_10_0(), semanticObject.getExpectedMaxTPA());
		feeder.accept(grammarAccess.getTaskProcessingAmountAccess().getExpectedMinTPAELongParserRuleCall_12_0(), semanticObject.getExpectedMinTPA());
		feeder.accept(grammarAccess.getTaskProcessingAmountAccess().getLinearBucketDistributionEBooleanParserRuleCall_14_0(), semanticObject.isLinearBucketDistribution());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         triggerStreamData=[StreamData|EString] 
	 *         implementingClassName=EString? 
	 *         (inputStreamData+=[StreamData|EString] inputStreamData+=[StreamData|EString]*)? 
	 *         returnedStreamData=[StreamData|EString]?
	 *     )
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Volume returns Volume
	 *
	 * Constraint:
	 *     (source=EString target=EString accessMode=VolumeAccessMode? type=VolumeType?)
	 * </pre>
	 */
	protected void sequence_Volume(ISerializationContext context, Volume semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Meter returns WorkflowLatencyMeter
	 *     WorkflowLatencyMeter returns WorkflowLatencyMeter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         monitoringPort=EString 
	 *         monitoringTime=ELong 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         metric=[WorkflowLatency|EString]? 
	 *         monitoringServer=[MonitoringService|EString]?
	 *     )
	 * </pre>
	 */
	protected void sequence_WorkflowLatencyMeter(ISerializationContext context, WorkflowLatencyMeter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns WorkflowLatency
	 *     WorkflowLatency returns WorkflowLatency
	 *
	 * Constraint:
	 *     (name=EString id=EString target=[Workflow|EString])
	 * </pre>
	 */
	protected void sequence_WorkflowLatency(ISerializationContext context, WorkflowLatency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.WORKFLOW_LATENCY__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.WORKFLOW_LATENCY__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkflowLatencyAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getWorkflowLatencyAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getWorkflowLatencyAccess().getTargetWorkflowEStringParserRuleCall_6_0_1(), semanticObject.eGet(PasysPackage.Literals.WORKFLOW_LATENCY__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns Workflow
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         ownedTasks+=Task 
	 *         ownedTasks+=Task* 
	 *         rootTask=[Task|ID] 
	 *         scheduler=[SchedulingService|EString] 
	 *         deploymentConfig=DeploymentConfiguration 
	 *         (ownedMeters+=WorkflowLatencyMeter ownedMeters+=WorkflowLatencyMeter*)? 
	 *         (ownedStreamData+=WorkflowStreamData ownedStreamData+=WorkflowStreamData*)? 
	 *         (ownedTaskExecutors+=TaskExecutor ownedTaskExecutors+=TaskExecutor*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SystemElement returns ZookeeperService
	 *     ZookeeperService returns ZookeeperService
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         id=EString 
	 *         serverId=EInt 
	 *         clientPort=EString 
	 *         tickTime=ELong 
	 *         leaderServers=EBoolean 
	 *         peerPort=EString 
	 *         leaderPort=EString 
	 *         initLimit=EInt 
	 *         syncLimit=EInt 
	 *         host=[ProcessingResourceCluster|EString] 
	 *         deploymentConfig=DeploymentConfiguration
	 *     )
	 * </pre>
	 */
	protected void sequence_ZookeeperService(ISerializationContext context, ZookeeperService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.NAMED_ELEMENT__ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__SERVER_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__SERVER_ID));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__CLIENT_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__CLIENT_PORT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__TICK_TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__TICK_TIME));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__LEADER_SERVERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__LEADER_SERVERS));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__PEER_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__PEER_PORT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__LEADER_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__LEADER_PORT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__INIT_LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__INIT_LIMIT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__SYNC_LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.ZOOKEEPER_SERVICE__SYNC_LIMIT));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.PLATFORM_SERVICE__HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.PLATFORM_SERVICE__HOST));
			if (transientValues.isValueTransient(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PasysPackage.Literals.DEPLOYABLE_COMPONENT__DEPLOYMENT_CONFIG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getIdEStringParserRuleCall_4_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getServerIdEIntParserRuleCall_6_0(), semanticObject.getServerId());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getClientPortEStringParserRuleCall_8_0(), semanticObject.getClientPort());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getTickTimeELongParserRuleCall_10_0(), semanticObject.getTickTime());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getLeaderServersEBooleanParserRuleCall_12_0(), semanticObject.isLeaderServers());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getPeerPortEStringParserRuleCall_14_0(), semanticObject.getPeerPort());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getLeaderPortEStringParserRuleCall_16_0(), semanticObject.getLeaderPort());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getInitLimitEIntParserRuleCall_18_0(), semanticObject.getInitLimit());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getSyncLimitEIntParserRuleCall_20_0(), semanticObject.getSyncLimit());
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getHostProcessingResourceClusterEStringParserRuleCall_22_0_1(), semanticObject.eGet(PasysPackage.Literals.PLATFORM_SERVICE__HOST, false));
		feeder.accept(grammarAccess.getZookeeperServiceAccess().getDeploymentConfigDeploymentConfigurationParserRuleCall_24_0(), semanticObject.getDeploymentConfig());
		feeder.finish();
	}
	
	
}
